# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/.rd/bin:$PATH"
export PATH="/opt/homebrew/opt/ruby/bin:$PATH"
export PATH="/opt/homebrew/lib/ruby/gems/4.0.0/bin:$PATH"

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME=""

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git zsh-autosuggestions zsh-syntax-highlighting)

# Skip compinit verification on startup (saves ~280ms)
ZSH_DISABLE_COMPFIX=true
DISABLE_UPDATE_PROMPT=true

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='nvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

alias c=chezmoi
alias mux=tmuxinator

# Configure tmux
if [ -t 0 ] && [ -z "$TMUX" ] && [ "$INTEGRATED_TERMINAL" != "true" ] && [ "$TERM_PROGRAM" != "vscode" ]; then
    tmux new-session -s "default-$(date +%s)" -c ~/dev
fi

# Set iTerm tab title to the active git worktree name
_set_iterm_tab_title_to_worktree() {
  local wt_path
  wt_path=$(git rev-parse --show-toplevel 2>/dev/null) || return
  local dir_name="${wt_path##*/}"
  # Only override the title inside worktree repos
  [[ "$wt_path" == */dev/*-worktree/* ]] && print -Pn "\e]2;${dir_name}\a"
}
precmd_functions+=(_set_iterm_tab_title_to_worktree)

# Configure FZF
source <(fzf --zsh)

# CTRL-Y to copy the command into clipboard using pbcopy
export FZF_CTRL_R_OPTS="
  --bind 'ctrl-y:execute-silent(echo -n {2..} | pbcopy)+abort'
  --color header:italic
  --header 'Press CTRL-Y to copy command into clipboard'"

# Preview file content using bat (https://github.com/sharkdp/bat)
export FZF_CTRL_T_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'bat -n --color=always {}'
  --bind 'ctrl-/:change-preview-window(down|hidden|)'"

# Print tree structure in the preview window
export FZF_ALT_C_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'tree -C {}'"


# Helpful funcitons
go() {
  local dir
  dir=$(find ~/dev -mindepth 1 -maxdepth 1 -type d | fzf --height=40% --reverse --prompt="~/dev: ")
  if [[ -n "$dir" ]]; then
    cd "$dir" || echo "Failed to cd into $dir"
  fi
}

# Create a git worktree with a new branch and open a tmux workspace
workspace() {
  if [[ $# -lt 3 ]]; then
    echo "Usage: workspace <repo> <worktree-name> <branch-name>"
    return 1
  fi

  local repo="$1"
  local wt_name="$2"
  local branch="$3"
  local repo_dir="$HOME/dev/$repo"
  local worktree_dir="$repo_dir/$wt_name"

  if [[ ! -d "$repo_dir" ]]; then
    echo "Error: Repository not found: $repo_dir"
    return 1
  fi

  if ! git -C "$repo_dir" rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not a git repository: $repo_dir"
    return 1
  fi

  # If worktree already exists, just launch the workspace
  if [[ -d "$worktree_dir" ]]; then
    echo "Worktree already exists, launching workspace..."
    tmuxinator start worktree "$worktree_dir"
    return 0
  fi

  echo "Creating worktree '$wt_name' (branch: $branch) in $repo_dir"
  if ! git -C "$repo_dir" worktree add "$worktree_dir" -b "$branch"; then
    echo "Error: Failed to create worktree"
    return 1
  fi

  tmuxinator start worktree "$worktree_dir"
}

# List all worktree workspaces in a categorized fzf picker and launch the selected one
workspaces() {
  local selected
  selected=$(
    for repo_dir in ~/dev/*-worktree; do
      [[ -d "$repo_dir" ]] || continue
      local repo_name="${repo_dir##*/}"
      repo_name="${repo_name%-worktree}"
      for wt in "$repo_dir"/*/; do
        [[ -d "$wt" ]] || continue
        local wt_name="${wt%/}"
        wt_name="${wt_name##*/}"
        echo "$repo_name/$wt_name"
      done
    done | fzf --height=40% --reverse --prompt="Workspace: "
  )

  if [[ -n "$selected" ]]; then
    local repo="${selected%%/*}"
    local wt="${selected#*/}"
    local target="$HOME/dev/${repo}-worktree/$wt"
    cd "$target" && mux workspace .
  fi
}

# Use fzf to select and checkout a git branch, sorted by recent activity
gbc() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local branch
  branch=$(git for-each-ref --format='%(refname:short) %(committerdate:relative)' --sort=-committerdate refs/heads/ | \
    fzf --height=40% --reverse --prompt="Checkout branch: " | \
    awk '{print $1}')
  
  if [[ -n "$branch" ]]; then
    git checkout "$branch"
  fi
}

# open the current directory in intellij
idea() {
  open -na "IntelliJ IDEA.app" --args "$@"
}

# Open current git branch in a new browser window using gh cli
ghb() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local branch=$(git branch --show-current)
  if [[ -z "$branch" ]]; then
    echo "Error: Could not determine current branch"
    return 1
  fi
  
  echo "Opening branch '$branch' in new window..."
  gh browse --branch "$branch"
}

# Git stash management with fzf - list, preview, apply, or drop stashes
gsf() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local stashes
  stashes=$(git stash list --format="%gd: %gs (%cr)" 2>/dev/null)
  
  if [[ -z "$stashes" ]]; then
    echo "No stashes found"
    return 0
  fi
  
  local selected
  selected=$(echo "$stashes" | \
    fzf --height=40% --reverse --prompt="Stash action: " \
        --preview="git stash show -p {1} --color=always" \
        --header="Enter=apply, Ctrl-D=drop, Ctrl-P=pop, Esc=cancel" \
        --bind="ctrl-d:execute(git stash drop {1})+reload(git stash list --format='%gd: %gs (%cr)')" \
        --bind="ctrl-p:accept" \
        --expect="ctrl-p")
  
  if [[ -n "$selected" ]]; then
    local key=$(echo "$selected" | head -1)
    local stash=$(echo "$selected" | tail -1 | awk '{print $1}')
    
    case "$key" in
      "ctrl-p")
        git stash pop "$stash"
        ;;
      *)
        git stash apply "$stash"
        ;;
    esac
  fi
}

# Delete tag locally and remotely, then create and push a new one
tag() {
  if [[ -z "$1" ]]; then
    echo "Usage: tag <tag-name>"
    return 1
  fi
  
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local tag_name="$1"
  
  echo "Processing tag: $tag_name"
  
  # Delete tag locally if it exists
  if git tag -l | grep -q "^${tag_name}$"; then
    echo "Deleting local tag: $tag_name"
    git tag -d "$tag_name"
  else
    echo "Local tag '$tag_name' does not exist"
  fi
  
  # Delete tag remotely if it exists
  echo "Attempting to delete remote tag: $tag_name"
  git push origin --delete "$tag_name" 2>/dev/null || echo "Remote tag '$tag_name' does not exist or already deleted"
  
  # Create new tag locally
  echo "Creating new local tag: $tag_name"
  git tag "$tag_name"
  
  # Push tag to remote
  echo "Pushing tag to remote: $tag_name"
  git push origin "$tag_name"
  
  echo "Tag '$tag_name' has been successfully recreated and pushed"
  
  # Extract repository name and print CCI workflows link
  local remote_url=$(git remote get-url origin 2>/dev/null)
  if [[ -n "$remote_url" ]]; then
    local repo_name=$(echo "$remote_url" | sed -E 's/.*[\/:]([^\/]+)\.git$/\1/')
    if [[ -n "$repo_name" ]]; then
      echo ""
      echo "CCI Workflows: https://app.gcp-circleci.build.corp.creditkarma.com/pipelines/github/ck-private/$repo_name"
    fi
  fi
}

function ds() {
    docker stop $(docker ps -q) && docker rm $(docker ps -aq)
}

function clone() {
   git clone https://code.corp.creditkarma.com/ck-private/"$@"
}

# Environment Exports

# Lazy-load nvm (saves ~900ms on shell startup)
export NVM_DIR="$HOME/.nvm"
# Put nvm's default node on PATH so starship detects the version without loading nvm
NVM_DEFAULT=$(cat "$NVM_DIR/alias/default" 2>/dev/null)
if [[ -n "$NVM_DEFAULT" && -d "$NVM_DIR/versions/node/$NVM_DEFAULT/bin" ]]; then
  export PATH="$NVM_DIR/versions/node/$NVM_DEFAULT/bin:$PATH"
elif [[ -n "$NVM_DEFAULT" ]]; then
  # Handle partial version aliases (e.g. "20" -> find matching installed version)
  NVM_MATCH=$(ls -d "$NVM_DIR/versions/node/$NVM_DEFAULT"*/bin 2>/dev/null | sort -V | tail -1)
  [[ -n "$NVM_MATCH" ]] && export PATH="$NVM_MATCH:$PATH"
fi
unset NVM_DEFAULT NVM_MATCH
nvm() {
  unset -f nvm node npm npx
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
  nvm "$@"
}
node() { unset -f nvm node npm npx; [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"; node "$@"; }
npm() { unset -f nvm node npm npx; [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"; npm "$@"; }
npx() { unset -f nvm node npm npx; [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"; npx "$@"; }

# Lazy-load jenv (saves ~200ms on shell startup)
export PATH="$HOME/.jenv/bin:$PATH"
jenv() {
  unset -f jenv
  eval "$(command jenv init -)"
  export JAVA_HOME="$(jenv prefix 2>/dev/null)"
  jenv "$@"
}
export JAVA_HOME="$HOME/.jenv/versions/$(cat "$HOME/.jenv/version" 2>/dev/null || echo "")"
export PATH="$PATH:/Users/msolomon1/Library/Application Support/Coursier/bin"
export PATH="$JAVA_HOME/bin:$HOME/.local/bin:$PATH"

{{ if .isWork }}
export GH_TOKEN="{{ onepasswordRead "op://Employee/ZSH GitHub Token/password" }}"
export GITHUB_TOKEN="{{ onepasswordRead "op://Employee/ZSH GitHub Token/password" }}"
#export ANTHROPIC_API_KEY="{{ onepasswordRead "op://Employee/AI Gateway Token/password" }}"
export ANTHROPIC_AUTH_TOKEN="{{ onepasswordRead "op://Employee/AI Gateway Token/password" }}"
export AI_GATEWAY_TOKEN="{{ onepasswordRead "op://Employee/AI Gateway Token GSA/password" }}"
export NEW_RELIC_OBS_NRTF_TOKEN="{{ onepasswordRead "op://Employee/Obs Nrtf Token/password" }}"
export ANTHROPIC_BASE_URL="https://ai-gateway.aitools.creditkarma.com/anthropic"
#export CIRCLE_OAUTH_TOKEN="{{ onepasswordRead "op://Employee/CircleCI OAuth Token/password" }}"
{{ else }}
export GH_TOKEN="{{ onepasswordRead "op://Personal/ZSH GitHub Token/password" }}"
# bun completions
[ -s "/Users/solomon/.bun/_bun" ] && source "/Users/solomon/.bun/_bun"
# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
{{ end  }}

# Starship prompt
eval "$(starship init zsh)"
